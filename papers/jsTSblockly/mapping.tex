% blockId is a constant, unique id for the block. This id is serialized in block code so changing it will break your users.
% block contains the syntax to build the block structure (more below).
% Other optional attributes can also be used:

% blockExternalInputs= forces External Inputs rendering
% advanced=true causes this block to be placed under the parent category’s “More…” subcategory. Useful for hiding advanced or rarely-used blocks by default
% Block syntax

\section{TypeScript to Blockly}

Types and namespaces are an integral part of the TypeScript language that
\MC uses to define the mapping from TypeScript to Blockly. If you aren't
familiar with TypeScript, please review the 
\href{https://www.typescriptlang.org/docs/handbook/basic-types.html}{TypeScript Handbook}.

\subsection{TypeScript Declaration File}

Internally, 
\MC uses a TypeScript declaration file (*.d.ts) to define
the mapping to custom blocks,
using specialized comments that further parameterize the mapping
defined by the declarations.  
The declaration file, which contains no implementation (definitions),
generally is automatically generated from a TypeScript implementation
file or files (*.ts) by a preprocessing step of the \MC build. 
The text below pertains to both kinds of files.  However, it is good to remember
that it is solely the TypeScript declarations (not the particulars of how
the declarations are implemented) that define the mapping to custom blocks. 

For a simple example of a declaration file, see
\url{https://github.com/Microsoft/pxt-sample/blob/master/libs/core/sims.d.ts}.


\subsection{Namespaces, Functions, and Primitive Values}

The mapping of TypeScript to Blockly is straighforward for namespaces,
functions and basic primitive values (such as boolean, number and string).
The mapping utility recognizes the special comment `//\%' before a function
definition $f$ to indicate that the function should be exported into the 
set of user-facing TypeScript APIs (but without a corresponding custom block). The
addition of the attribute `block` to the comment indicates that a custom
block should be generated for the exported TypeScript function.  In this way, 
\MC provides two APIs from a single function definition: one is the
TypeScript function $f$ itself; the second is a custom block, which represents
a potentially simplified call to $f$ (not using all the parameters provided by
$f$, for example).

In TypeScript, a set of related definitions may be grouped in a namespace.
These namespaces map to Toolbox categories in Blockly;
in particular, each top-level namespace is used to populate a category 
in the toolbox. 

As seen in the introduction, 
the general representation of a custom block is through the declaration/definition
of a TypeScript function $f$.  In particular, the custom block for $f$ usually
corresponds to a call (invocation) of function $f$, where the block's inputs
are transformed to parameters of function $f$.

\subsection{Function Typing}

The declared type of a function informs the kind of block that will be created:
\begin{itemize}
  \item a void return type for a function means its custom block will be a statement block;
  \item a non-void return type for a function means its custom block will be a value block;
  \item non-function parameters: optional parameters with default value; rest; 
  \item trailing function parameter: (top level block)
\end{itemize}

% Block syntax

% The block attribute specifies how the parameters of the function will be organized to create the block.

% block = field, { '|' field }
% field := string
%     | string `%` parameter [ `=` type ]
% parameter = string
% type = string
% each field is mapped to a field in the block editor
% the function parameter are mapped in order to %parameter argument. 

% The loader automatically builds a mapping between the block field names and the function names.
% the block will automatically switch to external inputs when enough parameters are detected
% A block type =type can be specified optionally for each parameter. It will be used to populate the shadow type.
% Supported types

\subsection{Enumerations}

\subsection{Objects and Object Destructuring}
API represented by
\begin{itemize}
  \item set of classes, with
  \item constructors
  \item methods/fields
\end{itemize}

\subsection{Event Handlers and Callbacks}

% \item event-handlers via a callback function (callbacks only have parameters with primitive values);

A function $f$ that has an argument $g$ of function type (in last position) will have
that function argument (callback) converted into a statement input of $B(f)$.

If the callback $g$ has parameters, then
the best way to map that pattern to the blocks is by modifying
$g$ to have a single parameter with a class type that has the
various parameters as fields.
For example:

% export class ArgumentClass {
%     argumentA: number;
%     argumentB: string;
% }

% //% mutate=objectdestructuring
% //% mutateText="My Arguments"
% //% mutateDefaults="argumentA;argumentA,argumentB"
% // ...
% export function addSomeEventHandler((a: ArgumentClass) => void) { };

% In the above example, setting mutate=objectdestructuring will cause this API 
% to use Blockly “mutators” to let users change what parameters appear in the blocks. 
% Each parameter will be given an optional variable field in the block that defines a 
% variable that can be used within the callback. The variable fields compile to object
% destructuring in the TypeScript code. For example:

% addSomeEventHandler(({argumentA, argumentB}) => {

% })

% For an example of this pattern in action, see the radio.onDataPacketReceived block in the microbit target.

% In some cases it can be useful to change the runtime behavior of the API based on the properties 
% selected by the user. To enable that behavior, create an enum with entries that have the same names 
% as the argument object’s properties and add an extra parameter taking in an enum array to the API. 
% For example:

% export class ArgumentClass {
%     argumentA: number;
%     argumentB: string;
% }

% enum ArgNames {
%     argumentA,
%     argumentB
% }

% //% mutate=objectdestructuring
% //% mutateText="My Arguments"
% //% mutateDefaults="argumentA;argumentA,argumentB"
% //% mutatePropertyEnum="argNames"
% // ...
% export function addSomeEventHandler(args: ArgNames[], (a: ArgumentClass) => void) { };
% Note the mutatePropertyEnum attribute added to the comment annotations. The block for this API will look the same as the previous example but the compiled code will also include the arguments passed:

% addSomeEventHandler([ArgNames.argumentA, ArgNames.argumentB], ({argumentA, argumentB}) => {

% })
% The other attributes related to object destructuring mutators include:

% mutateText - defines the text that appears in the top block of the Blockly mutator dialog (the dialog that appears when you click the blue gear)
% mutateDefaults - defines the versions of this block that should appear in the toolbox. Block definitions are separated by semicolons and property names should be separated by commas

